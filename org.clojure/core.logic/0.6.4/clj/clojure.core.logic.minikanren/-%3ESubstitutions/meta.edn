{:type :fn, :src "(deftype Substitutions [s l verify cs]\n  Object\n  (equals [this o]\n    (or (identical? this o)\n        (and (.. this getClass (isInstance o))\n             (= s ^clojure.lang.PersistentHashMap (.s ^Substitutions o)))))\n\n  ISubstitutions\n  (length [this] (count s))\n\n  (occurs-check [this u v]\n    (let [v (walk this v)]\n      (occurs-check-term v u this)))\n  \n  (ext [this u v]\n    (if (and *occurs-check* (occurs-check this u v))\n      nil\n      (ext-no-check this u v)))\n\n  (ext-no-check [this u v]\n    (verify this u v))\n\n  (swap [this cu]\n    (if (contains? s cu)\n      (let [v (s cu)]\n        (Substitutions. (-> s (dissoc cu) (assoc cu v)) l verify cs))\n      (Substitutions. (assoc s cu unbound) l verify cs)))\n\n  (constrain [this u c]\n    (let [u (walk this u)]\n      (swap this (add-constraint u c))))\n\n  (get-var [this v]\n    (first (find s v)))\n\n  (use-verify [this f]\n    (Substitutions. s l f cs))\n  \n  (walk [this v]\n    (loop [lv v [v vp] (find s v)]\n      (cond\n       (nil? v) lv\n       (identical? vp unbound) v\n       (not (lvar? vp)) vp\n       :else (recur vp (find s vp)))))\n  \n  (walk-var [this v]\n    (loop [lv v [v vp] (find s v)]\n      (cond\n       (nil? v) lv\n       (identical? vp unbound) v\n       (not (lvar? vp)) v\n       :else (recur vp (find s vp)))))\n  \n  (walk* [this v]\n    (let [v (walk this v)]\n      (walk-term v this)))\n\n  (unify [this u v]\n    (if (identical? u v)\n      this\n      (let [u (walk this u)\n            v (walk this v)]\n        (if (identical? u v)\n          this\n          (unify-terms u v this)))))\n\n  (reify-lvar-name [this]\n    (symbol (str \"_.\" (count s))))\n\n  (-reify [this v]\n    (let [v (walk this v)]\n      (reify-term v this)))\n\n  (reify [this v]\n    (let [v (walk* this v)]\n      (walk* (-reify empty-s v) v)))\n\n  (build [this u]\n    (build-term u this))\n\n  IBind\n  (bind [this g]\n    (g this))\n  IMPlus\n  (mplus [this f]\n    (choice this f))\n  ITake\n  (take* [this] this))", :ns "clojure.core.logic.minikanren", :name "->Substitutions", :file "clojure/core/logic/minikanren.clj", :column 1, :line 121, :arglists ([s l verify cs]), :doc "Positional factory function for class clojure.core.logic.minikanren.Substitutions."}