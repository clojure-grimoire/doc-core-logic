{:type :fn, :src "(deftype ConstraintStore [vmap cmap simple]\n  IConstraintStore\n  (merge-constraint [this c]\n                    (let [ks (keys c)]\n                      (reduce (fn [cs k] (assoc cs k c)) this ks))) ;; NOTE: switch to loop/recur?\n\n  (refine-constraint [this c u]\n                     (let [^Constraint c c\n                           name (.name c)\n                           ^Constraint c (dissoc (get cmap name) u)\n                           vmap (update-in vmap [u] #(disj % name))\n                           vmap (if (empty? (vmap u))\n                                  (dissoc vmap u)\n                                  vmap)]\n                       (if (= (count c) 1)\n                         (let [okeys (.okeys c)\n                               cmap (dissoc cmap name)\n                               vmap (reduce (fn [m v]\n                                              (update-in m [v] #(disj % name)))\n                                            vmap okeys)] ;; NOTE: hmm not all these keys exist\n                           ;; TODO: clear out empty vars like below\n                           (ConstraintStore. vmap cmap\n                                             (conj (or simple [])\n                                                   (first c))))\n                         (let [cmap (assoc cmap name c)]\n                           (ConstraintStore. vmap cmap simple)))))\n\n  (discard-constraint [this c]\n                      (let [^Constraint c c\n                            name (.name c)\n                            ^Constraint c (get cmap name)\n                            okeys (.okeys c)\n                            cmap (dissoc cmap name)\n                            vmap (reduce (fn [m v] ;; TODO: combine\n                                           (update-in m [v] #(disj % name)))\n                                         vmap okeys)\n                            vmap (reduce (fn [m v]\n                                           (if (empty? (m v))\n                                             (dissoc m v)\n                                             m))\n                                         vmap okeys)]\n                        (ConstraintStore. vmap cmap simple)))\n\n  (propagate [this s u v]\n             (if (contains? vmap u)\n               (let [cs (get this u)]\n                 (loop [[c & cr] cs me this]\n                   (if (nil? c)\n                     me\n                     (let [vp (walk s (get c u))]\n                       (cond\n                        (= vp v) (recur cr (refine-constraint me c u))\n                        (or (lvar? vp)\n                            (lvar? v)) (recur cr me)\n                            :else (recur cr (discard-constraint me c)))))))\n               this))\n\n  (get-simplified [this] simple)\n\n  (discard-simplified [this] (ConstraintStore. vmap cmap nil))\n\n  clojure.lang.Associative\n  (assoc [this u c]\n    (if (constraint? c)\n      (let [name (.name ^Constraint c)]\n        (ConstraintStore. (update-in vmap [u] (fnil #(conj % name) #{}))\n                          (assoc cmap name c) simple))\n      (throw (Exception. \"Adding something which is not a constraint\"))))\n\n  (containsKey [this key]\n               (contains? vmap key))\n\n  (entryAt [this key]\n           (when (contains? vmap key)\n             (let [val (when-let [s (seq (map #(cmap %) (vmap key)))]\n                         (vec s))]\n               (clojure.core/reify\n                clojure.lang.IMapEntry\n                (key [_] key)\n                (val [_] val)\n                Object\n                (toString [_] (.toString [key val]))))))\n\n  clojure.lang.ILookup\n  (valAt [this key]\n         (when (contains? vmap key)\n           (when-let [s (seq (map #(cmap %) (vmap key)))]\n             (vec s)))))", :ns "clojure.core.logic", :name "->ConstraintStore", :file "clojure/core/logic.clj", :column 1, :line 1972, :arglists ([vmap cmap simple]), :doc "Positional factory function for class clojure.core.logic.ConstraintStore."}