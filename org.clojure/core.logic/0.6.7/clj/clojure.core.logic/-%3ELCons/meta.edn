{:type :fn, :src "(deftype LCons [a d ^{:unsynchronized-mutable true :tag int} cache meta]\n  clojure.lang.IObj\n  (meta [this]\n    meta)\n  (withMeta [this new-meta]\n    (LCons. a d cache new-meta))\n  LConsSeq\n  (lfirst [_] a)\n  (lnext [_] d)\n  LConsPrint\n  (toShortString [this]\n    (cond\n     (.. this getClass (isInstance d)) (str a \" \" (toShortString d))\n     :else (str a \" . \" d )))\n  Object\n  (toString [this] (cond\n                    (.. this getClass (isInstance d)) (str \"(\" a \" \" (toShortString d) \")\")\n                    :else (str \"(\" a \" . \" d \")\")))\n  (equals [this o]\n    (or (identical? this o)\n        (and (.. this getClass (isInstance o))\n             (loop [me this\n                    you o]\n               (cond\n                (nil? me) (nil? you)\n                (lvar? me) true\n                (lvar? you) true\n                (and (lcons? me) (lcons? you))\n                  (let [mef  (lfirst me)\n                        youf (lfirst you)]\n                    (and (or (= mef youf)\n                             (lvar? mef)\n                             (lvar? youf))\n                         (recur (lnext me) (lnext you))))\n                :else (= me you))))))\n\n  (hashCode [this]\n    (if (= cache -1)\n      (do\n        (set! cache (uai (umi (int 31) (clojure.lang.Util/hash d))\n                         (clojure.lang.Util/hash a)))\n        cache)\n      cache))\n  IUnifyTerms\n  (unify-terms [u v s]\n    (unify-with-lseq v u s))\n  IUnifyWithNil\n  (unify-with-nil [v u s] false)\n  IUnifyWithObject\n  (unify-with-object [v u s] false)\n  IUnifyWithLSeq\n  (unify-with-lseq [v u s]\n    (loop [u u v v s s]\n      (if (lvar? u)\n        (unify s u v)\n        (cond\n         (lvar? v) (unify s v u)\n         (and (lcons? u) (lcons? v))\n           (if-let [s (unify s (lfirst u) (lfirst v))]\n             (recur (lnext u) (lnext v) s)\n             false)\n         :else (unify s u v)))))\n  IUnifyWithSequential\n  (unify-with-seq [v u s]\n    (unify-with-lseq u v s))\n  IUnifyWithMap\n  (unify-with-map [v u s] false)\n  IUnifyWithSet\n  (unify-with-set [v u s] false)\n  IReifyTerm\n  (reify-term [v s]\n    (loop [v v s s]\n      (if (lcons? v)\n        (recur (lnext v) (-reify* s (lfirst v)))\n        (-reify* s v))))\n  ;; TODO: no way to make this non-stack consuming w/o a lot more thinking\n  ;; we could use continuation passing style and trampoline\n  IWalkTerm\n  (walk-term [v s]\n    (lcons (walk* s (lfirst v))\n           (walk* s (lnext v))))\n  IOccursCheckTerm\n  (occurs-check-term [v x s]\n    (loop [v v x x s s]\n      (if (lcons? v)\n        (or (occurs-check s x (lfirst v))\n            (recur (lnext v) x s))\n        (occurs-check s x v))))\n  IBuildTerm\n  (build-term [u s]\n    (loop [u u s s]\n      (if (lcons? u)\n        (recur (lnext u) (build s (lfirst u)))\n        (build s u)))))", :ns "clojure.core.logic", :name "->LCons", :file "clojure/core/logic.clj", :column 1, :line 342, :arglists ([a d cache meta]), :doc "Positional factory function for class clojure.core.logic.LCons."}