{:type :fn, :src "(deftype Nom [lvar]\n  IBindable\n\n  Object\n  (toString [_]\n    (str \"<nom:\" (:name lvar) \">\"))\n  (hashCode [_]\n    (.hashCode lvar))\n  (equals [this o]\n    (and (.. this getClass (isInstance o))\n         (= lvar (:lvar o))))\n\n  clojure.lang.IObj\n  (withMeta [this new-meta]\n    (nom (with-meta lvar new-meta)))\n  (meta [this]\n    (meta lvar))\n\n  clojure.lang.ILookup\n  (valAt [this k]\n    (.valAt this k nil))\n  (valAt [_ k not-found]\n    (case k\n      :lvar lvar\n      :name (:name lvar)\n      :oname (:oname lvar)\n      not-found))\n\n  IReifyTerm\n  (reify-term [v s]\n    (ext s v (symbol (str (if (-> s meta (:reify-noms true)) \"a\" (:oname v)) \"_\" (count s)))))\n\n  INomSwap\n  (swap-noms [t swap s]\n    [(nom-swap t swap) s]))", :ns "clojure.core.logic.nominal", :name "->Nom", :file "clojure/core/logic/nominal.clj", :column 1, :line 71, :arglists ([lvar]), :doc "Positional factory function for class clojure.core.logic.nominal.Nom."}