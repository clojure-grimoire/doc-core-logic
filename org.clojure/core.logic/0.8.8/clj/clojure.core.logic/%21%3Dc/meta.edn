{:ns "clojure.core.logic", :name "!=c", :file "clojure/core/logic.clj", :type :fn, :src "(defn !=c [p]\n  (reify\n    ITreeConstraint\n    IConstraintStep\n    (-step [this s]\n      (reify\n        clojure.lang.IFn\n        (invoke [_ s]\n          (let [p (loop [sp (seq p) p p]\n                    (if sp\n                      (let [[x v] (first sp)\n                             ;; TODO: this seems expensive to walk* both sides\n                             ;; and run an equality test there must be a better\n                             ;; way - David\n                             xv (walk* s x)\n                             vv (walk* s v)]\n                        (cond\n                          (= xv vv) (recur (next sp) (dissoc p x))\n                          (nil? (unify s xv vv)) nil\n                          :else (recur (next sp) (assoc (dissoc p x) xv vv))))\n                      p))]\n            (if p\n              (when-not (empty? p)\n                ((composeg*\n                   (remcg this)\n                   (cgoal (!=c p))) s))\n              ((remcg this) s))))\n        IRunnable\n        (-runnable? [_]\n          (some #(not= (walk s %) %) (recover-vars p)))\n        IEntailed\n        (-entailed? [_]\n          (empty? p))))\n    IPrefix\n    (-prefix [_] p)\n    IWithPrefix\n    (-with-prefix [_ p] (!=c p))\n    IReifiableConstraint\n    (-reifyc [this v r a]\n      (let [p* (-reify a (map (fn [[lhs rhs]] `(~lhs ~rhs)) p) r)]\n        (if (empty? p*)\n          '()\n          `(~'!= ~@p*))))\n    IConstraintOp\n    (-rator [_] `!=)\n    (-rands [_] (seq (recover-vars p)))\n    IConstraintWatchedStores\n    (-watched-stores [this] #{::subst})))", :column 1, :line 2388, :arglists ([p])}