{:type :fn, :src "(deftype LCons [a d ^{:unsynchronized-mutable true :tag int} cache meta]\n  ITreeTerm\n  clojure.lang.IObj\n  (meta [this]\n    meta)\n  (withMeta [this new-meta]\n    (LCons. a d cache new-meta))\n\n  LConsSeq\n  (lfirst [_] a)\n  (lnext [_] d)\n\n  LConsPrint\n  (toShortString [this]\n    (cond\n     (.. this getClass (isInstance d)) (str a \" \" (toShortString d))\n     :else (str a \" . \" d )))\n\n  Object\n  (toString [this] (cond\n                    (.. this getClass (isInstance d))\n                      (str \"(\" a \" \" (toShortString d) \")\")\n                    :else (str \"(\" a \" . \" d \")\")))\n\n  (equals [this o]\n    (or (identical? this o)\n        (and (.. this getClass (isInstance o))\n             (loop [me this\n                    you o]\n               (cond\n                (nil? me) (nil? you)\n                (lvar? me) true\n                (lvar? you) true\n                (and (lcons? me) (lcons? you))\n                  (let [mef  (lfirst me)\n                        youf (lfirst you)]\n                    (and (or (= mef youf)\n                             (lvar? mef)\n                             (lvar? youf))\n                         (recur (lnext me) (lnext you))))\n                :else (= me you))))))\n\n  (hashCode [this]\n    (if (clojure.core/== cache -1)\n      (do\n        (set! cache (uai (umi (int 31) (clojure.lang.Util/hash d))\n                         (clojure.lang.Util/hash a)))\n        cache)\n      cache))\n\n  IUnifyTerms\n  (unify-terms [u v s]\n    (cond\n      (sequential? v)\n      (loop [u u v (seq v) s s]\n        (if-not (nil? v)\n          (if (lcons? u)\n            (if-let [s (unify s (lfirst u) (first v))]\n              (recur (lnext u) (next v) s)\n              nil)\n            (unify s u v))\n          (if (lvar? u)\n            (if-let [s (unify s u '())]\n              s\n              (unify s u nil))\n            nil)))\n\n      (lcons? v)\n      (loop [u u v v s s]\n        (if (lvar? u)\n          (unify s u v)\n          (cond\n            (lvar? v) (unify s v u)\n            (and (lcons? u) (lcons? v))\n            (if-let [s (unify s (lfirst u) (lfirst v))]\n              (recur (lnext u) (lnext v) s)\n              nil)\n            :else (unify s u v))))\n\n      :else nil))\n\n  IReifyTerm\n  (reify-term [v s]\n    (loop [v v s s]\n      (if (lcons? v)\n        (recur (lnext v) (-reify* s (lfirst v)))\n        (-reify* s v))))\n\n  ;; TODO: no way to make this non-stack consuming w/o a lot more thinking\n  ;; we could use continuation passing style and trampoline\n  IWalkTerm\n  (walk-term [v f]\n    (lcons (f (lfirst v))\n           (f (lnext v))))\n\n  IOccursCheckTerm\n  (occurs-check-term [v x s]\n    (loop [v v x x s s]\n      (if (lcons? v)\n        (or (occurs-check s x (lfirst v))\n            (recur (lnext v) x s))\n        (occurs-check s x v))))\n\n  IBuildTerm\n  (build-term [u s]\n    (loop [u u s s]\n      (if (lcons? u)\n        (recur (lnext u) (build s (lfirst u)))\n        (build s u)))))", :ns "clojure.core.logic", :name "->LCons", :file "clojure/core/logic.clj", :column 1, :line 741, :arglists ([a d cache meta]), :doc "Positional factory function for class clojure.core.logic.LCons."}