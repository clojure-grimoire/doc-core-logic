{:type :fn, :src "(deftype ConstraintStore [km cm cid running]\n  clojure.lang.ILookup\n  (valAt [this k]\n    (.valAt this k nil))\n  (valAt [this k not-found]\n    (case k\n      :km km\n      :cm cm\n      :cid cid\n      :running running\n      not-found))\n\n  IConstraintStore\n  (addc [this a c]\n    (when (or (not (instance? clojure.core.logic.protocols.IVerifyConstraint c))\n              (-verify c a this))\n      (let [vars (var-rands a c)\n            c    (with-id c cid)\n            cs   (reduce (fn [cs v] (add-var cs v c)) this vars)]\n        (ConstraintStore. (:km cs) (:cm cs) (inc cid) running))))\n\n  (updatec [this a c]\n    (let [oc (cm (id c))\n          nkm (if (instance? clojure.core.logic.protocols.IEntailedVar c)\n                (reduce (fn [km x]\n                          (if (-entailed-var? c x)\n                            (dissoc km x)\n                            km))\n                        km (var-rands a oc))\n                km)]\n      (ConstraintStore. nkm (assoc cm (id c) c) cid running)))\n\n  (remc [this a c]\n    (let [vs (var-rands a c)\n          ocid (id c)\n          nkm (reduce (fn [km v]\n                        (let [vcs (disj (get km v) ocid)]\n                          (if (empty? vcs)\n                            (dissoc km v)\n                            (assoc km v vcs))))\n                      km vs)\n          ncm (dissoc cm ocid)]\n      (ConstraintStore. nkm ncm cid running)))\n\n  (runc [this c state]\n    (if state\n      (ConstraintStore. km cm cid (conj running (id c)))\n      (ConstraintStore. km cm cid (disj running (id c)))))\n\n  (constraints-for [this a x ws]\n    (when-let [ids (get km (root-var a x))]\n      (filter #((-watched-stores %) ws) (map cm (remove running ids)))))\n\n  (migrate [this x root a]\n    (let [xcs    (km x)\n          rootcs (km root #{})\n          nkm    (assoc (dissoc km x) root (into rootcs xcs))]\n      (when (every?\n              (fn [c]\n                (if (instance? clojure.core.logic.protocols.IVerifyConstraint c)\n                  (-verify c a this)\n                  true))\n              (map cm xcs))\n        (ConstraintStore. nkm cm cid running))))\n\n  clojure.lang.Counted\n  (count [this]\n    (count cm)))", :ns "clojure.core.logic", :name "->ConstraintStore", :file "clojure/core/logic.clj", :column 1, :line 109, :arglists ([km cm cid running]), :doc "Positional factory function for class clojure.core.logic.ConstraintStore."}