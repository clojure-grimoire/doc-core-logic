{:type :fn, :src "(defrecord Tie [binding-nom body]\n  ITreeTerm\n\n  IUnifyTerms\n  (unify-terms [v u s]\n    (cond\n      (tie? u)\n      (if (= (:binding-nom v) (:binding-nom u))\n        (unify s (:body v) (:body u))\n        (let [[t s] (swap-noms (:body v) [(:binding-nom v) (:binding-nom u)] s)]\n          ((composeg* \n            (hash (:binding-nom u) (:body v))\n            (== t (:body u))) s)))\n      :else nil))\n\n  IReifyTerm\n  (reify-term [v s]\n    (let [s (-reify* s binding-nom)]\n      (let [s (-reify* s body)]\n        s)))\n\n  IWalkTerm\n  (walk-term [v f]\n    (with-meta\n      (tie (walk-term (:binding-nom v) f)\n           (walk-term (:body v) f))\n      (meta v)))\n\n  IOccursCheckTerm\n  (occurs-check-term [v x s]\n    (occurs-check s x (:body v)))\n\n  IConstrainTree\n  (-constrain-tree [t fc s]\n    (fc (:body t) s))\n\n  IForceAnswerTerm\n  (-force-ans [v x]\n    (force-ans (:body v)))\n\n  INomSwap\n  (swap-noms [t swap s]\n    (let [[tbody s] (swap-noms (:body t) swap s)]\n      [(with-meta (tie (nom-swap (:binding-nom t) swap) tbody) (meta t)) s])))", :ns "clojure.core.logic.nominal", :name "->Tie", :file "clojure/core/logic/nominal.clj", :column 1, :line 264, :arglists ([binding-nom body]), :doc "Positional factory function for class clojure.core.logic.nominal.Tie."}