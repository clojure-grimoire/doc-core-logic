{:type :fn, :src "(deftype MultiIntervalFD [min max is]\n  clojure.lang.ILookup\n  (valAt [this k]\n    (.valAt this k nil))\n  (valAt [this k not-found]\n    (case k\n      :is is\n      :min min\n      :max max\n      not-found))\n\n  Object\n  (equals [this j]\n    (if (instance? MultiIntervalFD j)\n      (let [i this\n            [jmin jmax] (bounds j)]\n        (if (and (= min jmin) (= max jmax))\n          (let [is (normalize-intervals is)\n                js (normalize-intervals (-intervals j))]\n            (= is js))\n          false))\n      false))\n\n  IMemberCount\n  (-member-count [this]\n    ;; NOTE: ugly hack around http://dev.clojure.org/jira/browse/CLJ-1202 - David\n    (reduce core/+ 0 (map #(-member-count %) is)))\n\n  IInterval\n  (-lb [_] min)\n  (-ub [_] max)\n\n  ISortedDomain\n  (-drop-one [_]\n    (let [i (first is)]\n      (if (singleton-dom? i)\n        (let [nis (rest is)]\n          (MultiIntervalFD. (-lb (first nis)) max nis))\n        (let [ni (-drop-one i)]\n          (MultiIntervalFD. (-lb ni) max (cons ni (rest is)))))))\n\n  (-drop-before [_ n]\n    (let [is (seq is)]\n      (loop [is is r []]\n        (if is\n          (let [i (-drop-before (first is) n)]\n            (if i\n              (recur (next is) (conj r i))\n              (recur (next is) r)))\n          (when (pos? (count r))\n            (apply multi-interval r))))))\n\n  (-keep-before [_ n]\n    (let [is (seq is)]\n      (loop [is is r []]\n        (if is\n          (let [i (-keep-before (first is) n)]\n            (if i\n              (recur (next is) (conj r i))\n              (recur (next is) r)))\n          (when (pos? (count r))\n            (apply multi-interval r))))))\n\n  ISet\n  (-member? [this n]\n    (if (some #(-member? % n) is)\n      true\n      false))\n  (-disjoint? [this that]\n    (disjoint?* this that))\n  (-intersection [this that]\n    (intersection* this that))\n  (-difference [this that]\n    (difference* this that))\n\n  IIntervals\n  (-intervals [this]\n    (seq is))\n\n  IMergeDomains\n  (-merge-doms [this that]\n    (-intersection this that)))", :ns "clojure.core.logic.fd", :name "->MultiIntervalFD", :file "clojure/core/logic/fd.clj", :column 1, :line 477, :arglists ([min max is]), :doc "Positional factory function for class clojure.core.logic.fd.MultiIntervalFD."}