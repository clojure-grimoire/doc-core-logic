{:ns "clojure.core.logic.fd", :name "*c", :file "clojure/core/logic/fd.clj", :type :fn, :src "(defn *c [u v w]\n  (letfn [(safe-div [n c a t]\n            (if (zero? n)\n              c\n              (let [q (core/quot a n)]\n                (case t\n                  :lower (if (pos? (rem a n))\n                           (inc q)\n                           q)\n                  :upper q))))]\n   (reify\n     IEnforceableConstraint\n     clojure.lang.IFn\n     (invoke [this s]\n       (let-dom s [u du v dv w dw]\n         (let [[wmin wmax] (if (domain? dw)\n                             (bounds dw)\n                             [(core/* (lb du) (lb dv)) (core/* (ub du) (ub dv))])\n               [umin umax] (if (domain? du)\n                             (bounds du)\n                             [(safe-div (ub dv) (lb dw) (lb dw) :lower)\n                              (safe-div (lb dv) (lb dw) (ub dw) :upper)])\n               [vmin vmax] (if (domain? dv)\n                             (bounds dv)\n                             [(safe-div (ub du) (lb dw) (lb dw) :lower)\n                              (safe-div (lb du) (lb dw) (ub dw) :upper)])\n               wi (interval (core/* umin vmin) (core/* umax vmax))\n               ui (interval (safe-div vmax umin wmin :lower)\n                            (safe-div vmin umax wmax :upper))\n               vi (interval (safe-div umax vmin wmin :lower)\n                            (safe-div umin vmax wmax :upper))]\n           ((composeg*\n             (process-dom w wi)\n             (process-dom u ui)\n             (process-dom v vi)\n             (*c-guard u v w)) s))))\n     IConstraintOp\n     (rator [_] `*)\n     (rands [_] [u v w])\n     IRelevant\n     (-relevant? [this s]\n       (let-dom s [u du v dv w dw]\n         (cond\n          (not (singleton-dom? du)) true\n          (not (singleton-dom? dv)) true\n          (not (singleton-dom? dw)) true\n          :else (not= (core/* du dv) dw))))\n     IRunnable\n     (runnable? [this s]\n       ;; we want to run even if w doesn't have a domain\n       ;; this is to support eqfd\n       (let-dom s [u du v dv w dw]\n         (cond\n          (domain? du) (or (domain? dv) (domain? dw))\n          (domain? dv) (or (domain? du) (domain? dw))\n          (domain? dw) (or (domain? du) (domain? dv))\n          :else false)))\n     IConstraintWatchedStores\n     (watched-stores [this]\n       #{::l/subst ::l/fd}))))", :column 1, :line 945, :arglists ([u v w])}