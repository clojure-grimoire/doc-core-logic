{:type :fn, :src "(deftype IntervalFD [_lb _ub]\n  Object\n  (equals [_ o]\n    (if (instance? IntervalFD o)\n      (and (= _lb (lb o))\n           (= _ub (ub o)))\n      false))\n\n  (toString [this]\n    (pr-str this))\n\n  IMemberCount\n  (member-count [this] (inc (core/- _ub _lb)))\n\n  IInterval\n  (lb [_] _lb)\n  (ub [_] _ub)\n\n  ISortedDomain\n  (drop-one [_]\n    (let [nlb (inc _lb)]\n      (when (core/<= nlb _ub)\n        (interval nlb _ub))))\n\n  (drop-before [this n]\n    (cond\n     (= n _ub) n\n     (core/< n _lb) this\n     (core/> n _ub) nil\n     :else (interval n _ub)))\n\n  (keep-before [this n]\n    (cond\n     (core/<= n _lb) nil\n     (core/> n _ub) this\n     :else (interval _lb (dec n))))\n\n  IFiniteDomain\n  (domain? [_] true)\n\n  ISet\n  (member? [this n]\n    (and (core/>= n _lb) (core/<= n _ub)))\n\n  (disjoint? [this that]\n    (cond\n     (integer? that)\n     (not (member? this that))\n\n     (interval? that)\n     (let [i this\n           j that\n           [imin imax] (bounds i)\n           [jmin jmax] (bounds j)]\n       (or (core/> imin jmax)\n           (core/< imax jmin)))\n\n     :else (disjoint?* this that)))\n\n  (intersection [this that]\n    (cond\n     (integer? that)\n     (if (member? this that)\n       that\n       nil)\n\n     (interval? that)\n     (let [i this j that\n           imin (lb i) imax (ub i)\n           jmin (lb j) jmax (ub j)]\n       (cond\n        (core/< imax jmin) nil\n        (core/< jmax imin) nil\n        (and (core/<= imin jmin)\n             (core/>= imax jmax)) j\n        (and (core/<= jmin imin)\n             (core/>= jmax imax)) i\n        (and (core/<= imin jmin)\n             (core/<= imax jmax)) (interval jmin imax)\n        (and (core/<= jmin imin)\n             (core/<= jmax imax)) (interval imin jmax)\n        :else (throw (Error. (str \"Interval intersection not defined \" i \" \" j)))))\n\n     :else (intersection* this that)))\n\n  (difference [this that]\n    (cond\n     (integer? that)\n     (cond\n      (= _lb that) (interval (inc _lb) _ub)\n      (= _ub that) (interval _lb (dec _ub))\n      :else (if (member? this that)\n              (multi-interval (interval _lb (dec that))\n                              (interval (inc that) _ub))\n              this))\n     \n     (interval? that)\n     (let [i this j that\n           imin (lb i) imax (ub i)\n           jmin (lb j) jmax (ub j)]\n       (cond\n        (core/> jmin imax) i\n        (and (core/<= jmin imin)\n             (core/>= jmax imax)) nil\n        (and (core/< imin jmin)\n             (core/> imax jmax)) (multi-interval (interval imin (dec jmin))\n             (interval (inc jmax) imax))\n        (and (core/< imin jmin)\n             (core/<= jmin imax)) (interval imin (dec jmin))\n        (and (core/> imax jmax)\n             (core/<= jmin imin)) (interval (inc jmax) imax)\n        :else (throw (Error. (str \"Interval difference not defined \" i \" \" j)))))\n     \n     :else (difference* this that)))\n\n  IIntervals\n  (intervals [this]\n    (list this))\n\n  IMergeDomains\n  (-merge-doms [this that]\n    (intersection this that)))", :ns "clojure.core.logic.fd", :name "->IntervalFD", :file "clojure/core/logic/fd.clj", :column 1, :line 247, :arglists ([_lb _ub]), :doc "Positional factory function for class clojure.core.logic.fd.IntervalFD."}