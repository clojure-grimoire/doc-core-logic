{:ns "clojure.core.logic", :name "!=c", :file "clojure/core/logic.clj", :type :fn, :src "(defn !=c\n  [p]\n  (reify\n    ITreeConstraint\n    clojure.lang.IFn\n    (invoke [this a]\n      (let [p (loop [sp (seq p) p p]\n                (if sp\n                  (let [[x v] (first sp)\n                        ;; TODO: this seems expensive to walk* both sides\n                        ;; and run an equality test there must be a better\n                        ;; way - David\n                        xv (walk* a x)\n                        vv (walk* a v)]\n                    (cond\n                      (= xv vv) (recur (next sp) (dissoc p x))\n                      (nil? (unify a xv vv)) nil\n                      :else (recur (next sp) (assoc (dissoc p x) xv vv))))\n                  p))]\n        (if p\n          (when-not (empty? p)\n            #_((normalize-store (with-prefix this p)) a)\n            ((composeg*\n              (remcg this)\n              (cgoal (!=c p))) a))\n          ((remcg this) a))))\n    IPrefix\n    (prefix [_] p)\n    IWithPrefix\n    (with-prefix [_ p] (!=c p))\n    IReifiableConstraint\n    (reifyc [this v r a]\n      (let [p* (-reify a (map (fn [[lhs rhs]] `(~lhs ~rhs)) p) r)]\n        (if (empty? p*)\n          '()\n          `(~'!= ~@p*))))\n    IConstraintOp\n    (rator [_] `!=)\n    (rands [_] (seq (recover-vars p)))\n    IRunnable\n    (runnable? [this s]\n      (some #(not= (walk s %) %) (recover-vars p)))\n    IRelevant\n    (-relevant? [this s]\n      (not (empty? p)))\n    IConstraintWatchedStores\n    (watched-stores [this] #{::subst})))", :column 1, :line 2478, :arglists ([p])}