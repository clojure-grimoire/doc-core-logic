{:type :fn, :src "(deftype LVar [id unique name oname hash meta]\n  IVar\n  clojure.lang.ILookup\n  (valAt [this k]\n    (.valAt this k nil))\n  (valAt [this k not-found]\n    (case k\n      :name name\n      :oname oname\n      :id id\n      not-found))\n\n  clojure.lang.IObj\n  (meta [this]\n    meta)\n  (withMeta [this new-meta]\n    (LVar. id unique name oname hash new-meta))\n\n  Object\n  (toString [_] (str \"<lvar:\" name \">\"))\n\n  (equals [this o]\n    (if (instance? IVar o)\n      (if unique\n        (identical? id (:id o))\n        (identical? name (:name o)))\n      false))\n\n  (hashCode [_] hash)\n\n  IUnifyTerms\n  (unify-terms [u v s]\n    (cond\n      (lvar? v)\n      (let [repoint (cond\n                      (-> u clojure.core/meta ::unbound) [u v]\n                      (-> v clojure.core/meta ::unbound) [v u]\n                      :else nil)]\n        (if repoint\n          (let [[root other] repoint]\n            (when-let [s (if (-> other clojure.core/meta ::unbound)\n                           (merge-with-root s other root)\n                           s)]\n              (let [s  (ext-no-check s other root)\n                    cs (migrate (:cs s) other root s)]\n                (when cs\n                  (assoc s :cs cs)))))\n          (ext-no-check s u v)))\n\n      (non-storable? v)\n      (throw (Exception. (str v \" is non-storable\")))\n\n      (not= v ::not-found)\n      (if (tree-term? v)\n        (ext s u v)\n        (if (-> u clojure.core/meta ::unbound)\n          (ext-no-check s u (assoc (root-val s u) :v v))\n          (ext-no-check s u v)))\n\n      :else nil))\n\n  IReifyTerm\n  (reify-term [v s]\n    (let [rf (-> s clojure.core/meta :reify-vars)]\n      (if (fn? rf)\n        (rf v s)\n        (if rf\n          (ext s v (reify-lvar-name s))\n          (ext s v (:oname v))))))\n\n  IWalkTerm\n  (walk-term [v f] (f v))\n\n  IOccursCheckTerm\n  (occurs-check-term [v x s] (= (walk s v) x))\n\n  IBuildTerm\n  (build-term [u s]\n    (let [m (:s s)\n          cs (:cs s)\n          lv (lvar 'ignore) ]\n      (if (contains? m u)\n        s\n        (make-s (assoc m u lv) cs)))))", :ns "clojure.core.logic", :name "->LVar", :file "clojure/core/logic.clj", :column 1, :line 614, :arglists ([id unique name oname hash meta]), :doc "Positional factory function for class clojure.core.logic.LVar."}