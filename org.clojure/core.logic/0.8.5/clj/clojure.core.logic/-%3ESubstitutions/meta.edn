{:type :fn, :src "(deftype Substitutions [s vs ts cs cq cqs oc _meta]\n  Object\n  (equals [this o]\n    (or (identical? this o)\n        (and (.. this getClass (isInstance o))\n             (= s (:s o)))))\n  ;; TODO: prn doesn't work anymore on empty-s, why not?\n  (toString [_] (str s))\n\n  clojure.lang.Counted\n  (count [this] (count s))\n\n  clojure.lang.IObj\n  (meta [this] _meta)\n  (withMeta [this new-meta]\n    (Substitutions. s vs ts cs cq cqs oc new-meta))\n\n  clojure.lang.ILookup\n  (valAt [this k]\n    (.valAt this k nil))\n  (valAt [this k not-found]\n    (case k\n      :s   s\n      :vs  vs\n      :ts  ts\n      :cs  cs\n      :cq  cq\n      :cqs cqs\n      :oc  oc\n      not-found))\n\n  clojure.lang.IPersistentCollection\n  (cons [this [k v]]\n    (if (lvar? k)\n      (assoc this k v)\n      (throw (Exception. (str \"key must be a logic var\")))))\n  (empty [this] empty-s)\n  (equiv [this o]\n    (.equals this o))\n\n  clojure.lang.Associative\n  (containsKey [this k]\n    (contains? #{:s :vs :cs :cq :cqs :oc} k))\n  (entryAt [this k]\n    (case k\n      :s   [:s s]\n      :vs  [:vs vs]\n      :ts  [:ts ts]\n      :cs  [:cs cs]\n      :cq  [:cq cq]\n      :cqs [:cqs cqs]\n      :oc  [:oc cqs]\n      nil))\n  (assoc [this k v]\n    (case k\n      :s   (Substitutions. v vs ts cs cq cqs oc _meta)\n      :vs  (Substitutions. s  v ts cs cq cqs oc _meta)\n      :ts  (Substitutions. s vs  v cs cq cqs oc _meta)\n      :cs  (Substitutions. s vs ts  v cq cqs oc _meta)\n      :cq  (Substitutions. s vs ts cs  v cqs oc _meta)\n      :cqs (Substitutions. s vs ts cs cq   v oc _meta)\n      :oc  (Substitutions. s vs ts cs cq cqs  v _meta)\n      (throw (Exception. (str \"Substitutions has no field for key\" k)))))\n\n  ISubstitutions\n  (ext-no-check [this u v]\n    (let [u (if-not (lvar? v)\n              (assoc-meta u ::root true)\n              u)]\n      (Substitutions. (assoc s u v) (if vs (conj vs u)) ts cs cq cqs oc _meta)))\n\n  (walk [this v]\n    (if (bindable? v)\n      (loop [lv v me (find s v)]\n        (if (nil? me)\n          lv\n          (let [v  (key me)\n                vp (val me)]\n            (if (not (bindable? vp))\n              (if (subst-val? vp)\n                (let [sv (:v vp)]\n                  (if (identical? sv ::unbound)\n                    (with-meta v (assoc (meta vp) ::unbound true))\n                    sv))\n                vp)\n              (recur vp (find s vp))))))\n      v))\n\n  ISubstitutionsCLP\n  (root-val [this v]\n    (if (lvar? v)\n      (loop [lv v [v vp :as me] (find s v)]\n        (cond\n          (nil? me) lv\n          (not (lvar? vp)) vp\n          :else (recur vp (find s vp))))\n      v))\n\n  (root-var [this v]\n    (if (lvar? v)\n      (if (-> v meta ::root)\n        v\n        (loop [lv v [v vp :as me] (find s v)]\n          (cond\n            (nil? me) lv\n\n            (not (lvar? vp))\n            (if (subst-val? vp)\n              (with-meta v (meta vp))\n              v)\n\n            :else (recur vp (find s vp)))))\n      v))\n\n  (ext-run-cs [this x v]\n    (let [x  (root-var this x)\n          xs (if (lvar? v)\n               [x (root-var this v)]\n               [x])\n          s  (if oc\n               (ext this x v)\n               (ext-no-check this x v))]\n      (when s\n        ((run-constraints* xs cs ::subst) s))))\n\n  (queue [this c]\n    (let [id (id c)]\n      (if-not (cqs id)\n        (-> this\n          (assoc :cq (conj (or cq []) c))\n          (assoc :cqs (conj cqs id)))\n        this)))\n\n  (update-var [this x v]\n    (assoc this :s (assoc (:s this) x v)))\n\n  IBind\n  (bind [this g]\n    (g this))\n  IMPlus\n  (mplus [this f]\n    (choice this f))\n  ITake\n  (take* [this] this))", :ns "clojure.core.logic", :name "->Substitutions", :file "clojure/core/logic.clj", :column 1, :line 272, :arglists ([s vs ts cs cq cqs oc _meta]), :doc "Positional factory function for class clojure.core.logic.Substitutions."}