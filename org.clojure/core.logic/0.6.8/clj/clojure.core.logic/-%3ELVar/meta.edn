{:type :fn, :src "(deftype LVar [name hash cs meta]\n  clojure.lang.IObj\n  (meta [this]\n    meta)\n  (withMeta [this new-meta]\n    (LVar. name hash cs meta))\n  Object\n  (toString [_] (str \"<lvar:\" name \">\"))\n  (equals [this o]\n    (and (.. this getClass (isInstance o))\n         (let [^LVar o o]\n           (identical? name (.name o)))))\n  (hashCode [_] hash)\n  ILVar\n  (constraints [_] cs)\n  (add-constraint [_ c] (LVar. name hash (conj (or cs #{}) c) meta))\n  (add-constraints [_ ds] (LVar. name hash (reduce conj (or cs #{}) ds) meta))\n  (remove-constraint [_ c] (LVar. name hash (disj cs c) meta))\n  (remove-constraints [_] (LVar. name hash nil meta))\n  IUnifyTerms\n  (unify-terms [u v s]\n    (unify-with-lvar v u s))\n  IUnifyWithNil\n  (unify-with-nil [v u s]\n    (ext-no-check s v u))\n  IUnifyWithObject\n  (unify-with-object [v u s]\n    (ext s v u))\n  IUnifyWithLVar\n  (unify-with-lvar [v u s]\n    (ext-no-check s u v))\n  IUnifyWithLSeq\n  (unify-with-lseq [v u s]\n    (ext s v u))\n  IUnifyWithSequential\n  (unify-with-seq [v u s]\n    (ext s v u))\n  IUnifyWithMap\n  (unify-with-map [v u s]\n    (ext s v u))\n  IUnifyWithSet\n  (unify-with-set [v u s]\n    (ext s v u))\n  IReifyTerm\n  (reify-term [v s]\n    (ext s v (reify-lvar-name s)))\n  IWalkTerm\n  (walk-term [v s] v)\n  IOccursCheckTerm\n  (occurs-check-term [v x s] (= (walk s v) x))\n  IBuildTerm\n  (build-term [u s]\n    (let [m (.s ^Substitutions s)\n          l (.l ^Substitutions s)\n          lv (lvar 'ignore) ]\n      (if (contains? m u)\n        s\n        (make-s (assoc m u lv)\n                (cons (Pair. u lv) l))))))", :ns "clojure.core.logic", :name "->LVar", :file "clojure/core/logic.clj", :column 1, :line 239, :arglists ([name hash cs meta]), :doc "Positional factory function for class clojure.core.logic.LVar."}